const express = require('express');
const mongoose = require('mongoose');
const multer = require('multer');
const path = require('path');
const QRCode = require('qrcode');
const crypto = require('crypto');
const cors = require('cors');
const axios = require('axios');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// –ö–≠–®–ò–†–û–í–ê–ù–ò–ï –í –ü–ê–ú–Ø–¢–ò –î–õ–Ø –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–û–ô –°–ö–û–†–û–°–¢–ò
const cache = new Map();
const CACHE_TTL = {
    points: 2 * 60 * 1000,     // 2 –º–∏–Ω—É—Ç—ã –¥–ª—è –ø—É–±–ª–∏—á–Ω—ã—Ö —Ç–æ—á–µ–∫
    admin: 1 * 60 * 1000,      // 1 –º–∏–Ω—É—Ç–∞ –¥–ª—è –∞–¥–º–∏–Ω—Å–∫–∏—Ö —Ç–æ—á–µ–∫
    leaderboard: 5 * 60 * 1000, // 5 –º–∏–Ω—É—Ç –¥–ª—è –ª–∏–¥–µ—Ä–±–æ—Ä–¥–∞
    collect: 10 * 60 * 1000    // 10 –º–∏–Ω—É—Ç –¥–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–±–æ—Ä–µ
};

function getFromCache(key) {
    const item = cache.get(key);
    if (!item) return null;
    
    if (Date.now() > item.expires) {
        cache.delete(key);
        return null;
    }
    
    return item.data;
}

function setCache(key, data, ttl) {
    cache.set(key, {
        data,
        expires: Date.now() + ttl
    });
}

function invalidateCache(pattern) {
    for (const key of cache.keys()) {
        if (key.includes(pattern)) {
            cache.delete(key);
        }
    }
}

// –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ –∫—ç—à–∞
setInterval(() => {
    const now = Date.now();
    for (const [key, item] of cache.entries()) {
        if (now > item.expires) {
            cache.delete(key);
        }
    }
}, 60000); // –ö–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É

// Middleware —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π
app.use(cors({
    origin: true,
    credentials: false,
    maxAge: 86400 // 24 —á–∞—Å–∞ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è CORS
}));

app.use(express.json({ 
    limit: '50mb',
    strict: false
}));

app.use(express.urlencoded({ 
    extended: true, 
    limit: '50mb',
    parameterLimit: 1000
}));

// –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–∞–π–ª—ã —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º
app.use(express.static('public', {
    maxAge: process.env.NODE_ENV === 'production' ? '1d' : '1h',
    etag: true,
    lastModified: true
}));

// Configure multer –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤
const storage = multer.memoryStorage();
const upload = multer({ 
    storage: storage,
    limits: {
        fileSize: 50 * 1024 * 1024, // 50MB
        files: 1
    },
    fileFilter: (req, file, cb) => {
        if (file.mimetype.startsWith('image/')) {
            cb(null, true);
        } else {
            cb(new Error('Only images allowed'), false);
        }
    }
});

// === –¢–ï–õ–ï–ì–†–ê–ú –ë–û–¢ ===
const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const BOT_USERNAME = process.env.TELEGRAM_BOT_USERNAME || 'PlasticBoyBot';
const WEBHOOK_PATH = `/webhook/${BOT_TOKEN}`;

console.log('ü§ñ Telegram Bot Configuration:');
console.log('Token available:', !!BOT_TOKEN);
console.log('Bot username:', BOT_USERNAME);

// –°–£–ü–ï–† –ë–´–°–¢–†–ê–Ø –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ä–æ–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD;
function ultraFastPasswordCheck(req) {
    const password = req.headers.authorization || req.headers['x-admin-password'] || req.get('Authorization');
    return password === ADMIN_PASSWORD;
}

// –ú–ì–ù–û–í–ï–ù–ù–´–ô HEAD endpoint –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–∞—Ä–æ–ª—è
app.head('/api/admin/points', (req, res) => {
    res.status(ultraFastPasswordCheck(req) ? 200 : 401).end();
});

// MongoDB Schema —Å –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –∏–Ω–¥–µ–∫—Å–∞–º–∏
const modelPointSchema = new mongoose.Schema({
    id: { type: String, required: true, unique: true, index: true },
    name: { type: String, required: true, index: 'text' },
    coordinates: {
        lat: { type: Number, required: true, index: true },
        lng: { type: Number, required: true, index: true }
    },
    qrCode: { type: String, required: true },
    qrSecret: { type: String, required: true, index: true },
    status: { type: String, enum: ['available', 'collected'], default: 'available', index: true },
    createdAt: { type: Date, default: Date.now, index: true },
    scheduledTime: { type: Date, default: Date.now, index: true },
    collectedAt: { type: Date, index: true },
    collectorInfo: {
        name: String,
        signature: String,
        selfie: String,
        authMethod: { type: String, enum: ['manual', 'telegram'], default: 'manual', index: true },
        telegramData: {
            id: { type: Number, index: true },
            first_name: String,
            last_name: String,
            username: String,
            photo_url: String,
            auth_date: Number,
            hash: String
        }
    }
}, {
    versionKey: false,
    minimize: false,
    strict: false
});

// –°–æ—Å—Ç–∞–≤–Ω—ã–µ –∏–Ω–¥–µ–∫—Å—ã –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤
modelPointSchema.index({ id: 1, qrSecret: 1 });
modelPointSchema.index({ status: 1, scheduledTime: 1 });
modelPointSchema.index({ status: 1, createdAt: -1 });
modelPointSchema.index({ 'collectorInfo.authMethod': 1, 'collectorInfo.telegramData.id': 1 });
modelPointSchema.index({ coordinates: '2dsphere' }); // –ì–µ–æ–∏–Ω–¥–µ–∫—Å –¥–ª—è –±—É–¥—É—â–∏—Ö —Ñ–∏—á

const ModelPoint = mongoose.model('ModelPoint', modelPointSchema);

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ Telegram —Å –ø—É–ª–æ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
const telegramAxios = axios.create({
    baseURL: `https://api.telegram.org/bot${BOT_TOKEN}`,
    timeout: 8000,
    maxRedirects: 0,
    headers: {
        'Content-Type': 'application/json',
        'Connection': 'keep-alive'
    }
});

async function sendTelegramMessage(chatId, message, options = {}) {
    if (!BOT_TOKEN) {
        console.log('‚ö†Ô∏è BOT_TOKEN not available');
        return;
    }
    
    try {
        const response = await telegramAxios.post('/sendMessage', {
            chat_id: chatId,
            text: message,
            parse_mode: 'Markdown',
            disable_web_page_preview: true,
            ...options
        });
        
        console.log(`‚úÖ Message sent to chat ${chatId}`);
        return response.data;
    } catch (error) {
        console.error('‚ùå Telegram error:', error.response?.data?.description || error.message);
        
        // Retry –±–µ–∑ markdown –ø—Ä–∏ –æ—à–∏–±–∫–µ –ø–∞—Ä—Å–∏–Ω–≥–∞
        if (error.response?.data?.description?.includes('parse')) {
            try {
                const response = await telegramAxios.post('/sendMessage', {
                    chat_id: chatId,
                    text: message.replace(/[*_`\[\]]/g, ''),
                    ...options,
                    parse_mode: undefined
                });
                return response.data;
            } catch (retryError) {
                console.error('‚ùå Retry failed:', retryError.response?.data);
            }
        }
        throw error;
    }
}

function getAppUrl(req) {
    return process.env.RENDER_EXTERNAL_URL || 
           `${req.get('x-forwarded-proto') || req.protocol}://${req.get('host')}`;
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ Telegram –∫–æ–º–∞–Ω–¥ —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º
async function handleTelegramUpdate(update, req) {
    try {
        if (update.message) {
            const message = update.message;
            const chatId = message.chat.id;
            const text = message.text;
            const user = message.from;
            
            if (text && text.startsWith('/')) {
                const command = text.split(' ')[0].substring(1).toLowerCase()
                    .replace(`@${BOT_USERNAME.toLowerCase()}`, '');
                
                const appUrl = getAppUrl(req);
                
                switch (command) {
                    case 'start':
                        await sendTelegramMessage(chatId, `üéØ *PlasticBoy - Almighty Edition*

Hello, ${user.first_name}! üëã

Welcome to the 3D model collection hunt in Almaty!

üéÆ *How to play:*
‚Ä¢ Find QR codes around the city
‚Ä¢ Scan them to collect models
‚Ä¢ Compete with other players

üèÜ Happy hunting!`, {
                            reply_markup: {
                                inline_keyboard: [
                                    [{ text: 'üó∫Ô∏è Open Map', url: appUrl }],
                                    [
                                        { text: 'üèÜ Leaderboard', callback_data: 'leaderboard' },
                                        { text: 'üìä Statistics', callback_data: 'stats' }
                                    ],
                                    [{ text: '‚ùì Help', callback_data: 'help' }]
                                ]
                            }
                        });
                        break;
                        
                    case 'stats':
                        await handleStatsCommand(chatId, appUrl);
                        break;
                        
                    default:
                        await sendTelegramMessage(chatId, `‚ùì Unknown command: /${command}

Use /start for main menu!`, {
                            reply_markup: {
                                inline_keyboard: [
                                    [{ text: 'üó∫Ô∏è Play Game', url: appUrl }]
                                ]
                            }
                        });
                }
            }
        }
        
        if (update.callback_query) {
            await handleCallbackQuery(update.callback_query, req);
        }
        
    } catch (error) {
        console.error('‚ùå Telegram update error:', error);
    }
}

// –ö—ç—à–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–ª—è –±–æ—Ç–∞
async function handleStatsCommand(chatId, appUrl) {
    try {
        let stats = getFromCache('telegram_stats');
        
        if (!stats) {
            const [totalPoints, collectedPoints, telegramStats] = await Promise.all([
                ModelPoint.countDocuments(),
                ModelPoint.countDocuments({ status: 'collected' }),
                ModelPoint.aggregate([
                    {
                        $match: {
                            status: 'collected',
                            'collectorInfo.authMethod': 'telegram'
                        }
                    },
                    {
                        $group: {
                            _id: null,
                            telegramCollections: { $sum: 1 },
                            uniqueTelegramUsers: { $addToSet: '$collectorInfo.telegramData.id' }
                        }
                    }
                ])
            ]);
            
            const tgStats = telegramStats[0] || { telegramCollections: 0, uniqueTelegramUsers: [] };
            
            stats = {
                totalPoints,
                availablePoints: totalPoints - collectedPoints,
                collectedPoints,
                telegramUsers: tgStats.uniqueTelegramUsers.length,
                telegramCollections: tgStats.telegramCollections
            };
            
            setCache('telegram_stats', stats, CACHE_TTL.points);
        }
        
        const statsMessage = `üìä *Game Statistics*

üì¶ Total Models: *${stats.totalPoints}*
üü¢ Available: *${stats.availablePoints}*
üî¥ Collected: *${stats.collectedPoints}*

üì± *Telegram Players:*
üë• Active Players: *${stats.telegramUsers}*
üéØ Their Collections: *${stats.telegramCollections}*

üèÜ Join the competition!`;
        
        await sendTelegramMessage(chatId, statsMessage, {
            reply_markup: {
                inline_keyboard: [
                    [{ text: 'üó∫Ô∏è Start Playing', url: appUrl }],
                    [{ text: 'üèÜ View Leaderboard', url: `${appUrl}/leaderboard.html` }]
                ]
            }
        });
    } catch (error) {
        console.error('‚ùå Stats error:', error);
        await sendTelegramMessage(chatId, '‚ùå Statistics temporarily unavailable');
    }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ callback –∑–∞–ø—Ä–æ—Å–æ–≤
async function handleCallbackQuery(callbackQuery, req) {
    const chatId = callbackQuery.message.chat.id;
    const data = callbackQuery.data;
    
    try {
        await telegramAxios.post('/answerCallbackQuery', {
            callback_query_id: callbackQuery.id,
            text: '‚úÖ'
        });
    } catch (e) {}
    
    const appUrl = getAppUrl(req);
    
    switch (data) {
        case 'stats':
            await handleStatsCommand(chatId, appUrl);
            break;
        case 'help':
            await sendTelegramMessage(chatId, `‚ùì *PlasticBoy Help*

üéÆ Find QR codes around Almaty and collect 3D models!

üì± Commands: /start, /stats
üó∫Ô∏è Open map to start playing
üèÜ Use Telegram login for leaderboard`, {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'üó∫Ô∏è Start Playing', url: appUrl }]
                    ]
                }
            });
            break;
        case 'leaderboard':
            await sendTelegramMessage(chatId, `üèÜ *Collectors Leaderboard*

View top PlasticBoy players!
Use Telegram login when collecting to join rankings!`, {
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'üèÜ View Leaderboard', url: `${appUrl}/leaderboard.html` }],
                        [{ text: 'üó∫Ô∏è Play Game', url: appUrl }]
                    ]
                }
            });
            break;
    }
}

// === WEBHOOK ROUTES ===
if (BOT_TOKEN) {
    app.post(WEBHOOK_PATH, async (req, res) => {
        res.status(200).send('OK');
        handleTelegramUpdate(req.body, req);
    });
    
    app.get('/setup-webhook', async (req, res) => {
        try {
            const appUrl = getAppUrl(req);
            const webhookUrl = `${appUrl}${WEBHOOK_PATH}`;
            
            await telegramAxios.post('/deleteWebhook');
            
            const response = await telegramAxios.post('/setWebhook', {
                url: webhookUrl,
                allowed_updates: ['message', 'callback_query'],
                drop_pending_updates: true
            });
            
            res.json({
                success: true,
                webhook_url: webhookUrl,
                response: response.data
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                error: error.response?.data || error.message
            });
        }
    });
    
    app.get('/webhook-info', async (req, res) => {
        try {
            const [webhookInfo, botInfo] = await Promise.all([
                telegramAxios.get('/getWebhookInfo'),
                telegramAxios.get('/getMe')
            ]);
            
            res.json({
                webhook_info: webhookInfo.data,
                bot_info: botInfo.data
            });
        } catch (error) {
            res.status(500).json({ error: error.response?.data || error.message });
        }
    });
}

// Connect to MongoDB —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π
const connectDB = async () => {
    try {
        await mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/plasticboy', {
            useNewUrlParser: true,
            useUnifiedTopology: true,
            maxPoolSize: 10,
            serverSelectionTimeoutMS: 5000,
            socketTimeoutMS: 45000,
            bufferMaxEntries: 0,
            bufferCommands: false
        });
        console.log('‚úÖ MongoDB connected');
    } catch (error) {
        console.error('‚ùå MongoDB error:', error);
        process.exit(1);
    }
};

// –£–°–ö–û–†–ï–ù–ù–´–ô Health check
app.get('/health', async (req, res) => {
    try {
        const dbState = mongoose.connection.readyState === 1 ? 'connected' : 'disconnected';
        
        res.json({
            status: 'OK',
            timestamp: new Date().toISOString(),
            database: dbState,
            cache_size: cache.size,
            telegram: !!BOT_TOKEN
        });
    } catch (error) {
        res.status(500).json({
            status: 'ERROR',
            error: error.message
        });
    }
});

// –°–£–ü–ï–† –ë–´–°–¢–†–´–ï API ROUTES —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º

// –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø—É–±–ª–∏—á–Ω—ã–µ —Ç–æ—á–∫–∏
app.get('/api/points', async (req, res) => {
    try {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
        let points = getFromCache('public_points');
        
        if (!points) {
            const now = new Date();
            
            // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∑–∞–ø—Ä–æ—Å —Å lean()
            points = await ModelPoint.find({
                scheduledTime: { $lte: now }
            })
            .select('-qrSecret -__v')
            .lean()
            .exec();
            
            setCache('public_points', points, CACHE_TTL.points);
        }
        
        res.set({
            'Cache-Control': 'public, max-age=120',
            'X-Cache': points ? 'HIT' : 'MISS'
        });
        
        res.json(points);
    } catch (error) {
        console.error('‚ùå Points error:', error);
        res.status(500).json({ error: 'Failed to load points' });
    }
});

// –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ—á–∫–µ –¥–ª—è —Å–±–æ—Ä–∞
app.get('/api/collect/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const { secret } = req.query;
        
        if (!secret) {
            return res.status(400).json({ error: 'Secret required' });
        }
        
        const cacheKey = `collect_${id}_${secret}`;
        let point = getFromCache(cacheKey);
        
        if (!point) {
            point = await ModelPoint.findOne({
                id: id.trim(),
                qrSecret: secret.trim()
            })
            .select('id name coordinates scheduledTime status')
            .lean()
            .exec();
            
            if (point) {
                setCache(cacheKey, point, CACHE_TTL.collect);
            }
        }
        
        if (!point) {
            return res.status(404).json({ error: 'Point not found' });
        }
        
        if (point.status === 'collected') {
            return res.status(409).json({ error: 'Already collected' });
        }
        
        const now = new Date();
        if (new Date(point.scheduledTime) > now) {
            return res.status(423).json({ 
                error: 'Not ready yet',
                scheduledTime: point.scheduledTime
            });
        }
        
        res.json({
            id: point.id,
            name: point.name,
            coordinates: point.coordinates,
            scheduledTime: point.scheduledTime
        });
    } catch (error) {
        console.error('‚ùå Collect info error:', error);
        res.status(500).json({ error: 'Failed to get point info' });
    }
});

// –°–æ–±—Ä–∞—Ç—å –º–æ–¥–µ–ª—å
app.post('/api/collect/:id', upload.single('selfie'), async (req, res) => {
    try {
        const { id } = req.params;
        const { secret, name, signature, authMethod, telegramData } = req.body;
        
        if (!secret || !name) {
            return res.status(400).json({ error: 'Secret and name required' });
        }
        
        const point = await ModelPoint.findOne({
            id: id.trim(),
            qrSecret: secret.trim()
        });
        
        if (!point) {
            return res.status(404).json({ error: 'Point not found' });
        }
        
        if (point.status === 'collected') {
            return res.status(409).json({ error: 'Already collected' });
        }
        
        const now = new Date();
        if (new Date(point.scheduledTime) > now) {
            return res.status(423).json({ error: 'Not ready yet' });
        }
        
        const collectorInfo = {
            name: name.trim(),
            signature: signature?.trim() || '',
            authMethod: authMethod || 'manual'
        };
        
        if (authMethod === 'telegram' && telegramData) {
            try {
                const parsed = typeof telegramData === 'string' ? JSON.parse(telegramData) : telegramData;
                if (parsed.id && parsed.first_name) {
                    collectorInfo.telegramData = {
                        id: parsed.id,
                        first_name: parsed.first_name,
                        last_name: parsed.last_name || '',
                        username: parsed.username || '',
                        photo_url: parsed.photo_url || '',
                        auth_date: parsed.auth_date,
                        hash: parsed.hash || ''
                    };
                }
            } catch (e) {
                collectorInfo.authMethod = 'manual';
            }
        }
        
        if (req.file) {
            collectorInfo.selfie = `data:${req.file.mimetype};base64,${req.file.buffer.toString('base64')}`;
        }
        
        point.status = 'collected';
        point.collectedAt = now;
        point.collectorInfo = collectorInfo;
        
        await point.save();
        
        // –ò–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º –∫—ç—à
        invalidateCache('public_points');
        invalidateCache('admin_points');
        invalidateCache('telegram_');
        
        console.log(`üéØ Collected: ${point.name} by ${collectorInfo.name}`);
        
        res.json({
            success: true,
            message: 'Collected successfully'
        });
    } catch (error) {
        console.error('‚ùå Collection error:', error);
        res.status(500).json({ error: 'Collection failed' });
    }
});

// ============== ADMIN ROUTES ==============

// –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ —Ç–æ—á–∫–∏ –¥–ª—è –∞–¥–º–∏–Ω–∞
app.get('/api/admin/points', async (req, res) => {
    try {
        if (!ultraFastPasswordCheck(req)) {
            return res.status(401).json({ error: 'Unauthorized' });
        }
        
        let points = getFromCache('admin_points');
        
        if (!points) {
            points = await ModelPoint.find({})
                .select('-__v')
                .lean()
                .exec();
            
            setCache('admin_points', points, CACHE_TTL.admin);
        }
        
        res.json(points);
    } catch (error) {
        console.error('‚ùå Admin points error:', error);
        res.status(500).json({ error: 'Failed to load points' });
    }
});

// –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é —Ç–æ—á–∫—É (–∞–¥–º–∏–Ω)
app.post('/api/admin/points', async (req, res) => {
    try {
        if (!ultraFastPasswordCheck(req)) {
            return res.status(401).json({ error: 'Unauthorized' });
        }

        const { name, coordinates, delayMinutes } = req.body;
        
        if (!name || !coordinates?.lat || !coordinates?.lng) {
            return res.status(400).json({ error: 'Invalid data' });
        }

        const pointId = Date.now().toString();
        const qrSecret = crypto.randomBytes(16).toString('hex');
        
        const scheduledTime = new Date();
        if (delayMinutes && !isNaN(delayMinutes)) {
            scheduledTime.setMinutes(scheduledTime.getMinutes() + parseInt(delayMinutes));
        }

        const appUrl = getAppUrl(req);
        const collectUrl = `${appUrl}/collect.html?id=${pointId}&secret=${qrSecret}`;
        
        const qrCodeDataUrl = await QRCode.toDataURL(collectUrl, {
            width: 400,
            margin: 2,
            color: { dark: '#000000', light: '#FFFFFF' }
        });

        const newPoint = new ModelPoint({
            id: pointId,
            name: name.trim(),
            coordinates: {
                lat: parseFloat(coordinates.lat),
                lng: parseFloat(coordinates.lng)
            },
            qrCode: qrCodeDataUrl,
            qrSecret,
            scheduledTime
        });

        await newPoint.save();
        
        // –ò–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º –∫—ç—à
        invalidateCache('admin_points');
        invalidateCache('public_points');
        
        console.log(`‚úÖ Point created: ${name}`);
        res.json(newPoint);
    } catch (error) {
        console.error('‚ùå Point creation error:', error);
        res.status(500).json({ error: 'Creation failed' });
    }
});

// –£–¥–∞–ª–∏—Ç—å —Ç–æ—á–∫—É (–∞–¥–º–∏–Ω)
app.delete('/api/admin/points/:id', async (req, res) => {
    try {
        if (!ultraFastPasswordCheck(req)) {
            return res.status(401).json({ error: 'Unauthorized' });
        }

        const { id } = req.params;
        const deletedPoint = await ModelPoint.findOneAndDelete({ id: id.trim() });
        
        if (!deletedPoint) {
            return res.status(404).json({ error: 'Point not found' });
        }

        // –ò–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º –∫—ç—à
        invalidateCache('admin_points');
        invalidateCache('public_points');
        
        console.log(`üóëÔ∏è Point deleted: ${deletedPoint.name}`);
        res.json({ success: true });
    } catch (error) {
        console.error('‚ùå Delete error:', error);
        res.status(500).json({ error: 'Delete failed' });
    }
});

// ============== TELEGRAM LEADERBOARD ==============

// –ü–æ–ª—É—á–∏—Ç—å –ª–∏–¥–µ—Ä–±–æ—Ä–¥ Telegram –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
app.get('/api/telegram/leaderboard', async (req, res) => {
    try {
        let data = getFromCache('telegram_leaderboard');
        
        if (!data) {
            const [leaderboard, stats] = await Promise.all([
                ModelPoint.aggregate([
                    {
                        $match: {
                            status: 'collected',
                            'collectorInfo.authMethod': 'telegram',
                            'collectorInfo.telegramData.id': { $exists: true, $ne: null }
                        }
                    },
                    {
                        $group: {
                            _id: '$collectorInfo.telegramData.id',
                            totalCollections: { $sum: 1 },
                            firstCollection: { $min: '$collectedAt' },
                            lastCollection: { $max: '$collectedAt' },
                            userData: { $first: '$collectorInfo.telegramData' }
                        }
                    },
                    {
                        $project: {
                            _id: 0,
                            totalCollections: 1,
                            firstCollection: 1,
                            lastCollection: 1,
                            id: '$userData.id',
                            first_name: '$userData.first_name',
                            last_name: '$userData.last_name',
                            username: '$userData.username',
                            photo_url: '$userData.photo_url'
                        }
                    },
                    {
                        $sort: { totalCollections: -1, firstCollection: 1 }
                    },
                    {
                        $limit: 50
                    }
                ]),
                
                ModelPoint.aggregate([
                    {
                        $match: {
                            status: 'collected',
                            'collectorInfo.authMethod': 'telegram'
                        }
                    },
                    {
                        $group: {
                            _id: null,
                            totalCollections: { $sum: 1 },
                            uniqueUsers: { $addToSet: '$collectorInfo.telegramData.id' }
                        }
                    },
                    {
                        $project: {
                            _id: 0,
                            totalCollections: 1,
                            totalUsers: { $size: '$uniqueUsers' }
                        }
                    }
                ])
            ]);

            const statsResult = stats[0] || { totalCollections: 0, totalUsers: 0 };

            data = {
                leaderboard,
                stats: statsResult,
                timestamp: new Date().toISOString()
            };
            
            setCache('telegram_leaderboard', data, CACHE_TTL.leaderboard);
        }
        
        res.set('Cache-Control', 'public, max-age=300');
        res.json(data);
    } catch (error) {
        console.error('‚ùå Leaderboard error:', error);
        res.status(500).json({ error: 'Failed to load leaderboard' });
    }
});

// ============== STATIC FILES ==============

const staticRoutes = ['/', '/admin', '/admin.html', '/collect.html', '/leaderboard.html'];
staticRoutes.forEach(route => {
    app.get(route, (req, res) => {
        const file = route === '/' ? 'index.html' : route.endsWith('.html') ? route.slice(1) : route.slice(1) + '.html';
        res.sendFile(path.join(__dirname, 'public', file));
    });
});

// 404 handler
app.use((req, res) => {
    res.status(404).json({ error: 'Not found' });
});

// Error handler
app.use((error, req, res, next) => {
    console.error('‚ùå Server error:', error);
    res.status(500).json({ error: 'Internal server error' });
});

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
const startServer = async () => {
    try {
        await connectDB();
        
        app.listen(PORT, () => {
            console.log('üöÄ PlasticBoy Server OPTIMIZED');
            console.log(`üìç URL: http://localhost:${PORT}`);
            console.log(`üõ°Ô∏è Admin: http://localhost:${PORT}/admin.html`);
            console.log(`üèÜ Leaderboard: http://localhost:${PORT}/leaderboard.html`);
            console.log(`üì± Telegram: @${BOT_USERNAME}`);
            console.log(`üíæ Cache: ${cache.size} entries`);
            
            if (BOT_TOKEN) {
                console.log(`üîó Webhook: ${WEBHOOK_PATH}`);
                console.log(`üîß Setup: http://localhost:${PORT}/setup-webhook`);
            }
        });
    } catch (error) {
        console.error('‚ùå Startup error:', error);
        process.exit(1);
    }
};

// Graceful shutdown
process.on('SIGTERM', () => {
    console.log('üìõ Shutting down...');
    cache.clear();
    mongoose.connection.close();
    process.exit(0);
});

process.on('SIGINT', () => {
    console.log('üìõ Shutting down...');
    cache.clear();
    mongoose.connection.close();
    process.exit(0);
});

startServer();
